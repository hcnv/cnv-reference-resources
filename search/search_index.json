{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"hCNV Reference Resources","text":""},{"location":"#data-tools-for-hcnv-analysis-with-a-focus-on-the-distributed-normal","title":"Data &amp; tools for hCNV analysis with a focus on the distributed normal","text":"<p>The site was started as a project of the ELIXIR hCNV Community at the Biohackathon Europe 2023:</p> <p>A \"batteries-included\" open reference resource for human genomic copy number variants (CNV)</p> <p>Main goals at the Biohackathon event were the identification of the best data formats, how to deploy a tailored Beacon solution as well as the selection of a data model for representing genomic variations and associated metadata.</p>"},{"location":"beacon-queries/","title":"Beacon CNV Queries","text":"<p>Beacon Project Query Documentation</p> <p>The Beacon project's documentation includes examples for current queries enabling discovery of CNVs (in resources supporting these formats).</p>"},{"location":"beacon-queries/#bracket-queries","title":"Bracket queries","text":""},{"location":"beacon-queries/#beacon-parameters","title":"Beacon parameters","text":"<ul> <li>In principle the <code>assemblyId</code> should not be needed if specifying the refseq ID</li> <li>Most beacons probably would go for <code>assemblyId</code> + chromosome-style <code>referenceName</code> (e.g. <code>9</code>)</li> </ul> Beacon v2 POST snippetBeacon v2 GET <pre><code>\"g_variant\": {\n    \"assemblyId\": \"GRCh38\",\n    \"end\": [21967753, 22500000],\n    \"referenceName\": \"refseq:NC_000009.12\",\n    \"start\": [21500000, 21975098],\n    \"variantType\": \"EFO:0030067\"\n}\n</code></pre> <pre><code>?assemblyId=GRCh38&amp;referenceName=refseq:NC_000009.12&amp;start=21500000,21975098&amp;end=21967753,22500000&amp;variantType=EFO:0030067\n</code></pre>"},{"location":"beacon-queries/#mongodb-translation","title":"MongoDB translation","text":"<p>The parameters in the MongoDB query represent a \"VRSified standard model\" structure - YMMV. Also, this example shows the expansion of the basic \"deletion\" code (EFO:0030067) into all its child terms.</p> <pre><code>{\n    \"$and\": [\n        {\"location.sequence_id\": \"refseq:NC_000009.12\"},\n        {\"location.start\": {\"$gte\": 21500000}},\n        {\"location.start\": {\"$lt\": 21975098}},\n        {\"location.end\": {\"$gte\": 21967753}},\n        {\"location.end\": {\"$lt\": 22500000}},\n        {\"variantState.id\": {\n                \"$in\": [\n                    \"EFO:0030067\",\n                    \"EFO:0030068\",\n                    \"EFO:0020073\",\n                    \"EFO:0030069\"\n                ]\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"data-resources/","title":"hCNV Reference Data Resources","text":""},{"location":"data-resources/#1000-genomes-dragen","title":"1000 Genomes Dragen","text":"<p>While primarily focused on somatic variants from cancer genomics the Progenetix resource also contains CNV data from the 1000 Genomes Project.</p> <ul> <li>1000 Genomes CNV at Progenetix</li> </ul> <p>TBD</p>"},{"location":"mongodb-pymongo/","title":"MongoDB and Pymongo Cheats","text":""},{"location":"mongodb-pymongo/#set-up-a-mondodb","title":"Set up a MondoDB","text":"<p>Create a new Directory in your repository with a db folder in it. Directory/db</p> <p>Create a YAML file named docker-compose.yaml and copy this script to it.</p> <pre><code>version: '3.6'\nservices:\n\n  mongo-client:\n    image: mongo:3.6\n    restart: unless-stopped\n    volumes:\n      - ./beacon/db:/data/db\n    ports:\n      - \"27017:27017\"\n\n  mongo-express:\n    image: mongo-express\n    restart: unless-stopped\n    environment:\n      - ME_CONFIG_MONGODB_SERVER=mongo-client\n      - ME_CONFIG_MONGODB_PORT=27017\n      - ME_CONFIG_BASICAUTH_USERNAME=admin\n      - ME_CONFIG_BASICAUTH_PASSWORD=adminpass\n    ports:\n      - \"8081:8081\"\n</code></pre> <p>Run the commands below to create a docker container.</p> <pre><code>docker-compose up -d\ndocker exec -it mongo-client bash\n</code></pre> <p>To get more information about the created container for example NAMES and PORTS run the docker ps command</p>"},{"location":"mongodb-pymongo/#database-manipulation-in-python","title":"Database Manipulation in Python","text":"<p>The following code creates a databas with a variants collection.</p> <pre><code>from pymongo import MongoClient\nfrom datetime import datetime\n\ndb_client = MongoClient() # if you work on a vertual machine you might need to change this into db_client = MongoClient(\"&lt;docker ps IP&gt;\",27017)\ndatabase = db_client[\"cnv_reference_db\"]\nvar_coll = database[\"variants\"]\n\nvariants = [\n    {\n      \"info\": { \"cn_count\": 1 },\n      \"biosample_id\": \"testsample-0001\",\n      \"variant_internal_id\": '11:52900000-134452384:EFO_0030067',\n      \"variant_state\": { \"id\": 'EFO:0030067', \"label\": 'copy number loss' },\n      \"location\": {\n        \"sequence_id\": 'refseq:NC_000011.10',\n        \"chromosome\": '11',\n        \"start\": 52900000,\n        \"end\": 134452384\n      },\n      \"relative_copy_class\": 'partial loss',\n      \"updated\": datetime.now().isoformat()\n    }\n]\n\nfor v in variants:\n    vid = var_coll.insert_one(v).inserted_id\n    vstr = f'refvar-{vid}'\n    var_coll.update_one({'_id':vid},{'$set':{ 'id':vstr }})\n    print(f'==&gt; inserted {vstr}')\n</code></pre>"},{"location":"parameters-and-mappings/","title":"hCNV Parameters and Mappings to Output format","text":""},{"location":"parameters-and-mappings/#collected-parameters","title":"Collected Parameters","text":""},{"location":"parameters-and-mappings/#variants-data","title":"Variants data","text":"<ul> <li>CNV type (DUP, DEL...)<ul> <li>translated to EFO terms using CN count values</li> </ul> </li> <li>referenceName<ul> <li>chromosome translated to refseq id w/ prefix</li> </ul> </li> <li>start<ul> <li>left-shifted since 0-based coordinates instead of VCFs 1-based</li> </ul> </li> <li>end<ul> <li>from INFO</li> </ul> </li> <li>CN count<ul> <li>from call field</li> </ul> </li> <li>assemblyId<ul> <li>from header (GRCh38)</li> </ul> </li> <li>...</li> </ul>"},{"location":"parameters-and-mappings/#metadata","title":"Metadata","text":"<ul> <li>sample id</li> <li>donor id? different?</li> <li>sequencing platform</li> <li>sequencing library / model (?)</li> <li>sex</li> <li>ethnicity ...</li> <li>geographic provenance</li> <li>external references, e.g. biosamples collection ID (as CURIE) and associated   publication(s)</li> <li>...</li> </ul>"},{"location":"parameters-and-mappings/#parameter-output-mappings","title":"Parameter Output Mappings","text":"<p>Output Model</p> <p>The information below just gives some indications about the way these are handled in the Beacon default model and its Progenetix variant. However, the current idea is to go directly for a representation through Phenopackets (which has many similarities to Beacon v2 but a different unified wrapper model).</p> <p>For comparison please see the Phenopacket example from Progenetix. The same can be accessed through Progenetix using progenetix.org/beacon/phenopackets/onekgind-HG00320. Please be aware that this example doesn't contain some of the \"interesting\" parameters like technical provenance or population background.</p>"},{"location":"parameters-and-mappings/#beacon-v2-default-model-for-genomicvariation","title":"Beacon v2 Default Model for <code>genomicVariation</code>","text":"<ul> <li>Beacon v2 default model source</li> <li>Beacon v2 default model documentation</li> </ul> <p>Beacon v2 provides a default model with its main data entities <code>individual</code>, <code>biosample</code>, <code>analysis</code>, <code>run</code> and <code>genomicVariation</code>. The parameters needed for an hCNV reference resource potentially map to all of those entities; e.g.</p> <ul> <li>donor sex  =&gt; <code>individual.sex</code></li> </ul>"},{"location":"parameters-and-mappings/#progenetix-bycon-parameter-mappings","title":"Progenetix <code>bycon</code> parameter mappings","text":"<p>The Progenetix implementation of the Beacon API - through the <code>bycon</code> stack - closely adheres internally to the Beacon v2 default model. Specifically, records are stored in document formats described in JSON Schema with overall correspondance to the standard Beacon models, and stored in a MongoDB database with per schema collections (<code>individuals</code>, <code>biosamples</code>, <code>callsets</code> and <code>variants</code> as well as helper collections for e.g. ontologies or genome lookups).</p> <p>For data I/O the <code>bycon</code> package contains a mapping file which allows to map data from columnar (i.e. tab delimited) input files to the corresponding attributes in the document schemas.</p>"},{"location":"parameters-and-mappings/#example-bycon-parameter-mappings","title":"Example <code>bycon</code> parameter mappings","text":"<pre><code>  genomicVariant:\n    type: object\n    parameters:\n      variant_id:\n        db_key: id\n        indexed: True\n        compact: True\n        computed: True\n      variant_internal_id:\n        type: string\n        db_key: variant_internal_id\n        indexed: True\n        compact: True\n        computed: True\n      callset_id:\n        description: |\n            The bycon model uses `callset` to store\n            information corresponding to Beacon's `analysis`\n            and `run` entities.\n        type: string\n        db_key: callset_id\n        indexed: True\n        compact: True\n      biosample_id:\n        type: string\n        db_key: biosample_id\n        indexed: True\n        compact: True\n      individual_id:\n        type: string\n        db_key: individual_id\n        indexed: True\n        compact: True\n      sequence_id:\n        type: string\n        db_key: location.sequence_id\n        indexed: True\n        compact: True\n      reference_name:\n        type: string\n        db_key: location.chromosome\n        indexed: True\n        compact: True\n      start:\n        type: integer\n        db_key: location.start\n        indexed: True\n        compact: True\n      end:\n        type: integer\n        db_key: location.end\n        indexed: True\n        compact: True\n      variant_state_id:\n        type: string\n        db_key: variant_state.id\n        indexed: True\n        compact: True\n      variant_state_label:\n        type: string\n        db_key: variant_state.label\n        compact: True\n      reference_bases:\n        type: string\n        db_key: reference_sequence\n        indexed: True\n        compact: True\n      alternate_bases:\n        type: string\n        db_key: sequence\n        indexed: True\n        compact: True\n      annotation_derived:\n        type: boolean\n        db_key: info.annotation_derived\n        default: False\n        indexed: True\n      aminoacid_changes:\n        type: array\n        items: string\n        db_key: molecular_attributes.aminoacid_changes\n        indexed: True\n      genomic_hgvs_id:\n        type: string\n        db_key: identifiers.genomicHGVS_id\n        indexed: True\n\n      # special pgxseg columns\n\n      log2:\n        db_key: info.cnv_value\n        type: number\n      variant_type:\n        type: string\n        db_key: variant_type\n</code></pre>"},{"location":"vcfdata-mongodb/","title":"Variants data collection in MongoDB","text":""},{"location":"vcfdata-mongodb/#variants-in-mongod","title":"Variants in MongoD","text":"<p>Below is the MongoDB_importer.py</p> <pre><code>from pymongo import MongoClient\nimport argparse\nimport json\n\ndef MongoDBimporter():\n    parser = argparse.ArgumentParser(description='Input arguments')\n    parser.add_argument('-i', '--input_json_file', type=str, default='', help='Input a file path to the JSON file to import')\n    parser.add_argument('-d', '--database_name', type=str, default='', help='Name the created MongoDB database')\n    parser.add_argument('-v', '--variant_file_name', type=str, default='', help='Name the Variant file in the MongoDB database')\n    parser.add_argument('-ip', '--MongoDB_IP_address', type=str, default='localhost', help='Input MongoDB IP address')\n    args = parser.parse_args()\n    if args.input_json_file == '':\n        print('Input JSON file')\n        parser.print_help()\n        exit(1)\n    if args.database_name == '':\n        print('Add database name')\n        parser.print_help()\n        exit(1)\n    if args.variant_file_name == '':\n        print('Add variant file name')\n        parser.print_help()\n        exit(1)\n    if args.MongoDB_IP_address == '':\n        print('Input MongoDB IP address')\n        parser.print_help()\n        exit(1)\n\n    db_client = MongoClient(args.MongoDB_IP_address,27017)\n    database = db_client[args.database_name]\n    var_coll = database[args.variant_file_name]\n\n    # Function to read JSON data from a file\n    def read_json_file(file_path):\n        try:\n            with open(file_path, 'r') as json_file:\n                variants = json.load(json_file)\n                return variants\n        except FileNotFoundError:\n            print(f\"File not found: {file_path}\")\n        except json.JSONDecodeError as e:\n            print(f\"JSON decoding error: {e}\")\n\n    variants = read_json_file(args.input.json_file)\n    if variants is not None:\n        for v in variants:\n            vid = var_coll.insert_one(v).inserted_id\n            vstr = f'refvar-{vid}'\n            var_coll.update_one({'_id': vid}, {'$set': {'id': vstr}})\n            print(f'==&gt; inserted {vstr}')\n\nMongoDBimporter()\n</code></pre>"}]}